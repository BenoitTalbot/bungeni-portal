# encoding: utf-8

import zope.security.management

from zope import component
from zope.formlib import form, namedtemplate
from zope import schema, interface
from zope.app.pagetemplate import ViewPageTemplateFile
from zope.traversing.browser import absoluteURL 

from ore.workflow import interfaces

from bungeni.models import domain
from bungeni.core import globalsettings as prefs
from bungeni.core.i18n import _
from bungeni.ui.queries import statements as sqlstatements
from bungeni.ui.queries import utils as sqlutils
from bungeni.ui.forms.workflow import createVersion
from bungeni.ui.forms import validations
from bungeni.ui.forms.common import ReorderForm
from bungeni.ui.forms.common import AddForm
from bungeni.ui.forms.common import EditForm

FormTemplate = namedtemplate.NamedTemplateImplementation(
    ViewPageTemplateFile('templates/form.pt')
    )

def hasDeletePermission(context):
    """Generic check if the user has rights to delete the object. The
    permission must follow the convention:
    ``bungeni.<classname>.Delete`` where 'classname' is the lowercase
    of the name of the python class.
    """
    
    interaction = zope.security.management.getInteraction()
    class_name = context.__class__.__name__ 
    permission_name = 'bungeni.' + class_name.lower() +'.Delete'
    return interaction.checkPermission(permission_name, context)

def set_widget_errors(widgets, errors):
    """Display invariant errors / custom validation errors in the
    context of the field."""

    for widget in widgets:
        name = widget.context.getName()
        for error in errors:
            if isinstance(error, interface.Invalid) and name in error.args[1:]:
                if widget._error is None:
                    widget._error = error

def flag_changed_widgets( widgets, context, data):
    for widget in widgets:
        name = widget.context.getName()
        # If the field is not in the data, then go on to the next one
        if name not in data:
            widget.changed = False
            continue
        if data[name] == getattr(context, name):
            widget.changed = False
        else:
            widget.changed = True  
    return []                  

class CustomEditForm ( EditFormViewlet ):
    """
    Override the autogenerated Edit form for specific behaviour
    """  
    Adapts = None
    CustomValidations = None
    template = NamedTemplate('alchemist.subform')       
    
    def _can_edit(self):
        """
        check for edit permissions
        """
        #TODO
        return True
    
    
    def _can_delete( self ):
        return hasDeletePermission(self.context)

    def _can_attach( self ):        
        #result =  IFileAttachments.providedBy( self.context )    
        return False
    
    def _getDefaultActions(self):
        actions = []
        if self._can_edit():
            action = form.Action(_(u'Save'), success='handle_edit_action')
            action.form = self
            actions.append(action)
        if self._can_attach():
            action = form.Action(_(u'Attach a file'), success='handle_save_attach')
            action.form = self
            actions.append(action)
                            
        #cancel is allways available... 
        action = form.Action(_(u'Cancel'), success= 'handle_cancel_action')
        action.form = self   
        actions.append(action)

        if self._can_delete():                  
            action = form.Action(_(u'Delete'), success= 'handle_delete_action')
            action.form = self
            actions.append(action)   
        return actions          
     

    def setupActions( self ):
        self.actions = self._getDefaultActions()    
          
          
    def update( self ):
        """
        adapt the custom fields to our object
        """
        self.setupActions()  
        self.adapters = {self.Adapts  : self.context }    
        super( CustomEditForm, self).update()        
        set_widget_errors(self.widgets, self.errors)   
       
        
    def validate(self, action, data):    
        """
        validation that require context must be called here,
        invariants may be defined in the descriptor
        """                                          
        return (form.getWidgetsData(self.widgets, self.prefix, data) +
                 form.checkInvariants(self.form_fields, data) +
                 flag_changed_widgets( self.widgets, self.context, data) +     
                 self.CustomValidations( self.context, data) )  

    def invariantErrors( self ):        
        """ All invariant errors should be handled by the fields that raised them """
        return []    
        
    
    #form.action(_(u"delete"), condition=can_delete, validator=null_validator)
    def handle_delete_action( self, action, data):    
        """
        deletes the current content and takes you to the listing
        """        
        if self.can_delete(action):
            context = removeSecurityProxy(self.context)
            session = Session()
            session.delete(context)
            url = absoluteURL( self.context.__parent__, self.request )  + '?portal_status_message=Object deleted'
            return self.request.response.redirect( url )
    
    #form.action(_(u"Cancel"), condition=form.haveInputWidgets, validator=null_validator)
    def handle_cancel_action( self, action, data ):
        """ the cancel action will take us back to the display view"""
        #return handle_edit_action( self, action, data )                    
        url = absoluteURL( self.context, self.request )  + '?portal_status_message=No Changes'
        return self.request.response.redirect( url )
        
                
        
    #form.action(_(u"Save"), condition=form.haveInputWidgets)
    def handle_edit_action( self, action, data ):
        """ Save action will take us: 
        If there were no errors to the display view
        If there were Errors to the edit view
        """
        result = handle_edit_action( self, action, data )                                 
        if self.errors: 
            return result
        else:            
            url = absoluteURL( self.context, self.request )  
            return self.request.response.redirect( url )        

    #form.action(_(u"Save and attach files"), condition=can_attach )
    def handle_save_attach( self, action, data ):        
        result = handle_edit_action( self, action, data )                                 
        if self.errors: 
            return result
        else:            
            url = absoluteURL( self.context, self.request )   + '/files'
            return self.request.response.redirect( url  )    
                        
                      
                              

class ResponseEditForm( EditForm ):
    """ Answer a Question
    UI for ministry to input response
    Display the question when adding the answer.
    """
    CustomValidations =  validations.null_validator

    
class ResponseAddForm( AddForm ):
    """
    Answer a Question
    UI for ministry to input response
    Display the question when adding the answer.
    """
    CustomValidation =  validations.null_validator

    
class ItemScheduleContainerReorderForm(ReorderForm):
    """Specialization of the general reorder form for item
    schedulings."""
    
    def save_ordering(self, ordering):
        for name, scheduling in self.context.items():
            scheduling.planned_order = ordering.index(name)
    
