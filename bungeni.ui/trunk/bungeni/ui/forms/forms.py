# encoding: utf-8

from zope import component
from zope.formlib import form, namedtemplate
from zope import schema, interface
from zope.formlib.namedtemplate import NamedTemplate
from zope.app.pagetemplate import ViewPageTemplateFile
from zope.traversing.browser import absoluteURL 
from zope.security.proxy import removeSecurityProxy
from zope.publisher.browser import BrowserView

import zope.security.management

from ore.alchemist.vocabulary import DatabaseSource
from ore.alchemist import Session
from ore.workflow import interfaces
from ore.yuiwidget import calendar
from ore.alchemist.model import queryModelDescriptor

from alchemist.ui.content import ContentAddForm
from alchemist.ui.viewlet import EditFormViewlet
from alchemist.ui.core import null_validator
from alchemist.ui.core import handle_edit_action

import bungeni.ui.queries.utils as sqlutils 
import bungeni.models.domain as domain

from bungeni.ui.queries import sqlstatements

from bungeni.ui.forms.workflow import bindTransitions
from bungeni.ui.forms.workflow import createVersion

from bungeni.models.interfaces import \
     IGroupSitting, \
     IParliamentSession, \
     IMemberOfParliament, \
     ICommittee, \
     ICommitteeMember, \
     IGovernment, \
     IMinistry, \
     IExtensionGroup, \
     IMinister, \
     IExtensionMember, \
     IParliament, \
     IGroupSittingAttendance, \
     ICommitteeStaff, \
     IMemberRoleTitle, \
     IMemberOfParty, \
     IPoliticalParty, \
     IQuestion, \
     IResponse

from bungeni.core.i18n import _

import bungeni.core.globalsettings as prefs
from bungeni.models.interfaces import IFileAttachments 
from bungeni.ui.widgets import  SelectDateTimeWidget, SelectDateWidget
from bungeni.ui import widgets

import validations

FormTemplate = namedtemplate.NamedTemplateImplementation(
    ViewPageTemplateFile('templates/form.pt')
    )

class BungeniAddForm(ContentAddForm):
    """
    Override the autogenerated Add form for custom behaviour
    """
    Adapts = {} 
    CustomValidation = None

    @property
    def form_name( self ):
        descriptor = queryModelDescriptor( self.context.domain_model )
        if descriptor:
            name = getattr( descriptor, 'display_name', None)
        if not name:
            name = getattr( self.context.domain_model, '__name__', None)                
        return _(u"add_item_legend", default=u"Add $name",
                 mapping={'name': name.lower()})

    def update( self ):
         self.status = self.request.get('portal_status_message','')
         form.AddForm.update( self )
         set_widget_errors(self.widgets, self.errors)


    def finishConstruction( self, ob ):
        """
        adapt the custom fields to the object
        """
        self.adapters = { self.Adapts : ob }    

             
    def validate(self, action, data):    
        """
        validation that require context must be called here,
        invariants may be defined in the descriptor
        """                                          
        return (form.getWidgetsData(self.widgets, self.prefix, data) +
                 form.checkInvariants(self.form_fields, data) +
                 self.CustomValidation( self.context, data ) )  
    
    
    @form.action(_(u"Save"), condition=form.haveInputWidgets)
    def handle_add_save(self, action, data ):
        """
        After succesfull creation of the content we are back at the listing
        """
        self.createAndAdd( data )
        name = self.context.domain_model.__name__
        self._next_url = absoluteURL( self.context, self.request ) + '?portal_status_message=%s Added'%name    
        
    @form.action(_(u"Cancel"), validator=null_validator )
    def handle_cancel( self, action, data ):
        """
        takes us back to the listing
        """
        url = self.nextURL()
        return self.request.response.redirect( url )
        
    @form.action(_(u"Save and continue editing"), condition=form.haveInputWidgets, validator='validateAdd')
    def handle_add_edit( self, action, data ):
        ob = self.createAndAdd( data )
        name = self.context.domain_model.__name__
        self._next_url = absoluteURL( ob, self.request ) + "/@@edit?portal_status_message=%s Added"%name
        
    @form.action(_(u"Save and add another"), condition=form.haveInputWidgets)
    def handle_add_and_another(self, action, data ):
        self.createAndAdd( data )
        name = self.context.domain_model.__name__
        self._next_url = absoluteURL( self.context, self.request ) + '/@@add?portal_status_message=%s Added'%name        



#parliament        
class ParliamentAdd( BungeniAddForm ):
    """
    custom Add form for parliaments
    """
    form_fields = form.Fields( IParliament )
    form_fields["start_date"].custom_widget = calendar.CalendarWidget
    #form_fields["end_date"].custom_widget = SelectDateWidget  
    form_fields["election_date"].custom_widget = calendar.CalendarWidget
    form_fields["description"].custom_widget=widgets.RichTextEditor
    Adapts = IParliament
    CustomValidation = validations.CheckParliamentDatesAdd  
    
class PoliticalPartyAdd( BungeniAddForm ):
    """
    custom Add form for parliaments
    """
    form_fields = form.Fields( IPoliticalParty )
    form_fields["start_date"].custom_widget = SelectDateWidget
    form_fields["end_date"].custom_widget = SelectDateWidget  
    form_fields["description"].custom_widget=widgets.RichTextEditor
    Adapts = IPoliticalParty
    CustomValidation = validations.checkPartyDates

# party membership



class PartyMemberAdd( BungeniAddForm ):
    """
    add a person to a party
    """
    #XXX

class MemberOfPartyAdd( BungeniAddForm ):
    """
    add a partymembership to a person
    """
    #XXX
    form_fields = form.Fields( IMemberOfParty )
    form_fields["start_date"].custom_widget = SelectDateWidget
    form_fields["end_date"].custom_widget = SelectDateWidget
    form_fields["notes"].custom_widget=widgets.RichTextEditor
    Adapts = IMemberOfParty    
    CustomValidation = validations.checkPartyMembershipDates


# ministries
class MinistryAdd( BungeniAddForm ):
    """
    custom Add form for ministries
    """
    form_fields = form.Fields( IMinistry )
    form_fields["start_date"].custom_widget = SelectDateWidget
    form_fields["end_date"].custom_widget = SelectDateWidget
    Adapts = IMinistry
    CustomValidation =  validations.CheckMinistryDatesInsideGovernmentDatesAdd     
                      

                 
#ministers



qryAddMinisterVocab = sqlutils.SQLQuerySource(sqlstatements.sql_addMinister, 'fullname', 'user_id')

class IMinisterAdd( IMinister ):
    """
    override some fields with custom schema
    """
    user_id = schema.Choice(title=_(u"Minister"),  
                                source=qryAddMinisterVocab, 
                                required=True,
                                )
    
    
class MinistersAdd( BungeniAddForm ):
    """
    custom Add form for ministries
    """
    form_fields = form.Fields( IMinisterAdd ).select(
                    'user_id', 
                    'start_date', 'end_date',
                    'notes')
    form_fields["start_date"].custom_widget = SelectDateWidget
    form_fields["end_date"].custom_widget = SelectDateWidget
    form_fields["notes"].custom_widget=widgets.RichTextEditor
    Adapts = IMinisterAdd
    CustomValidation =   validations.CheckMinisterDatesInsideMinistryDatesAdd    
                       
    
# government

class GovernmentAdd ( BungeniAddForm ):
    """
    custom Add form for government
    """
    form_fields = form.Fields( IGovernment )
    form_fields["start_date"].custom_widget = SelectDateWidget
    form_fields["end_date"].custom_widget = SelectDateWidget 
    Adapts = IGovernment
    CustomValidation =  validations.CheckGovernmentsDateInsideParliamentsDatesAdd    
                      
   

# Extension groups

class ExtensionGroupAdd( BungeniAddForm ):
    """
    override the AddForm for GroupSittingAttendance
    """
    form_fields = form.Fields( IExtensionGroup )
    form_fields["start_date"].custom_widget = SelectDateWidget
    form_fields["end_date"].custom_widget = SelectDateWidget 
    Adapts = IExtensionGroup
    CustomValidation =   validations.CheckExtensionGroupDatesInsideParentDatesAdd   
 


qryAddExtensionMemberVocab = sqlutils.SQLQuerySource(sqlstatements. sql_addExtensionMember, 'fullname', 'user_id')

class IExtensionMemberAdd( IExtensionMember ):
    """
    override some fields for extension group members
    """
    user_id = schema.Choice(title=_(u"Person"),  
                                source=qryAddExtensionMemberVocab, 
                                required=True,
                                )
                                
                                
# Members of extension Groups
class ExtensionMemberAdd( BungeniAddForm ):
    """
    override the AddForm for GroupSittingAttendance
    """
    form_fields = form.Fields( IExtensionMemberAdd ).omit( "replaced_id", "substitution_type" )
    form_fields["start_date"].custom_widget = SelectDateWidget
    form_fields["end_date"].custom_widget = SelectDateWidget 
    form_fields["notes"].custom_widget=widgets.RichTextEditor
    Adapts = IExtensionMemberAdd
    CustomValidation =  validations.CheckExtensionMemberDatesInsideParentDatesAdd    
                      

# CommitteeMemberAdd




qryAddCommitteeMemberVocab = sqlutils.SQLQuerySource(sqlstatements. sql_AddCommitteeMember, 'fullname', 'user_id')

class ICommitteeMemberAdd ( ICommitteeMember ):
    """
    override some fields with custom schema
    """
    user_id = schema.Choice(title=_(u"Member of Parliament"),  
                                source=qryAddCommitteeMemberVocab, 
                                required=True,
                                )
class CommitteeMemberAdd( BungeniAddForm ):
    """
    override the AddForm for GroupSittingAttendance
    """
    form_fields = form.Fields( ICommitteeMemberAdd ).select(
                    'user_id', 
                    'start_date', 'end_date',
                    'notes')
    form_fields["start_date"].custom_widget = SelectDateWidget
    form_fields["end_date"].custom_widget = SelectDateWidget
    form_fields["notes"].custom_widget=widgets.RichTextEditor
    Adapts = ICommitteeMemberAdd
    CustomValidation =  validations.CheckCommitteeMembersDatesInsideParentDatesAdd     
                      
# committee staff


                        
qryAddCommitteeStaffVocab = sqlutils.SQLQuerySource(sqlstatements.sql_AddCommitteeStaff, 'fullname', 'user_id')

class ICommitteeStaffAdd ( ICommitteeStaff ):
    """
    override some fields with custom schema
    """
    user_id = schema.Choice(title=_(u"Staff Member"),  
                                source=qryAddCommitteeStaffVocab, 
                                required=True,
                                )
                                
class CommitteeStaffAdd( BungeniAddForm ):
    """
    override the AddForm 
    """
    form_fields = form.Fields( ICommitteeStaffAdd ).select(
                    'user_id', 
                    'start_date', 'end_date',
                    'notes')
    form_fields["start_date"].custom_widget = SelectDateWidget
    form_fields["end_date"].custom_widget = SelectDateWidget
    form_fields["notes"].custom_widget=widgets.RichTextEditor
    Adapts = ICommitteeStaffAdd
    CustomValidation =  validations.CheckCommitteeMembersDatesInsideParentDatesAdd   


# Committees


class CommitteeAdd( BungeniAddForm ):
    """
    override the AddForm for GroupSittingAttendance
    """
    form_fields = form.Fields( ICommittee )
    form_fields["start_date"].custom_widget = SelectDateWidget
    form_fields["end_date"].custom_widget = SelectDateWidget    
    form_fields["reinstatement_date"].custom_widget = SelectDateWidget 
    Adapts = ICommittee
    CustomValidation = validations.CheckCommitteesDatesInsideParentDatesAdd     
                      

# Members of Parliament




qryAddMemberOfParliamentVocab = sqlutils.SQLQuerySource(sqlstatements.sql_AddMemberOfParliament, 'fullname', 'user_id')  

class IMemberOfParliamentAdd ( IMemberOfParliament ):
    """ Custom schema to override some autogenerated fields"""
    user_id = schema.Choice(title=_(u"Member of Parliament"),  
                                source=qryAddMemberOfParliamentVocab, 
                                required=True,
                                )


class MemberOfParliamentAdd( BungeniAddForm ):
    """
    override the AddForm for GroupSittingAttendance
    """
    #form_fields = form.Fields( IMemberOfParliamentAdd ).omit( "replaced_id", "substitution_type" )
    form_fields = form.Fields( IMemberOfParliamentAdd ).select(
                    'user_id', 'start_date', 
                    'election_nomination_date', 'elected_nominated',  'constituency_id',
                    'end_date', 'leave_reason',
                    'notes')
    form_fields["start_date"].custom_widget = SelectDateWidget
    form_fields["end_date"].custom_widget = SelectDateWidget 
    form_fields["start_date"].field.description = _(u"Begin of the parliamentary mandate")
    #form_fields["start_date"].field.title = _(u"Beginn of the parliamentary mandate")    
    form_fields["election_nomination_date"].custom_widget = SelectDateWidget   
    form_fields["notes"].custom_widget=widgets.RichTextEditor 
    Adapts = IMemberOfParliamentAdd
    CustomValidation = validations.CheckMPsDatesInsideParentDatesAdd  
    
    def update( self ):      
        edate = getattr(self.context.__parent__, 'election_date', None)       
        if edate:
            self.form_fields["election_nomination_date"].field.default = edate                    
        sdate = getattr(self.context.__parent__, 'start_date', None)     
        if sdate:
            self.form_fields["start_date"].field.default = sdate                 
        super( MemberOfParliamentAdd, self ).update()  
    

# Sessions

    
class SessionAdd( BungeniAddForm ):
    """
    override the AddForm for GroupSittingAttendance
    """
    form_fields = form.Fields( IParliamentSession )
    form_fields["start_date"].custom_widget = SelectDateWidget
    form_fields["end_date"].custom_widget = SelectDateWidget 
    Adapts = IParliamentSession
    CustomValidation =  validations.CheckSessionDatesInsideParentDatesAdd    
                      
 

# Sittings



class GroupSittingAdd( BungeniAddForm ):
    """
    override the AddForm for GroupSittingAttendance
    """
    form_fields = form.Fields( IGroupSitting )
    form_fields["start_date"].custom_widget = SelectDateTimeWidget
    form_fields["end_date"].custom_widget = SelectDateTimeWidget
    Adapts = IGroupSitting
    CustomValidation =  validations.CheckSittingDatesInsideParentDatesAdd 
                      
        
     


membersAddVocab = sqlutils.SQLQuerySource(sqlstatements.sql_add_members, 'user_name', 'user_id')      
attendanceVocab = DatabaseSource(domain.AttendanceType, 'attendance_type', 'attendance_id' )

# Sitting Attendance

class IGroupSittingAttendanceAdd( interface.Interface ):
    """ """
    member_id = schema.Choice(title=_(u"Member of Parliament"),  
                                source=membersAddVocab, 
                                required=True,
                                )
    attendance_id = schema.Choice( title=_(u"Attendance"),  
                                    source=attendanceVocab, 
                                    required=True,
                                    )  



class GroupSittingAttendanceAdd( ContentAddForm ):
    """
    override the AddForm for GroupSittingAttendance
    """
    form_fields = form.Fields( IGroupSittingAttendanceAdd )
                      
    def update(self):
        """
        Called by formlib after __init__ for every page update. This is
        the method you can use to update form fields from your class
        """        
        self.status = self.request.get('portal_status_message','')        
        form.AddForm.update( self )
        set_widget_errors(self.widgets, self.errors)
         
    def finishConstruction( self, ob ):
        """
        adapt the custom fields to the object
        """
        self.adapters = { IGroupSittingAttendanceAdd : ob }


                                  
titleAddVocab =  sqlutils.SQLQuerySource(sqlstatements.sql_addMemberTitle, 'ordered_title', 'user_role_type_id')

# Titles / Roles

     
class IMemberRoleTitleAdd( IMemberRoleTitle ):
    title_name_id = schema.Choice( title=_(u"Title"),  
                                    source=titleAddVocab, 
                                    required=True,
                                    )  
     
class MemberTitleAdd( BungeniAddForm ):
    form_fields = form.Fields( IMemberRoleTitleAdd ).select('title_name_id', 'start_date', 'end_date')
    form_fields["start_date"].custom_widget = SelectDateWidget
    form_fields["end_date"].custom_widget = SelectDateWidget
    Adapts = IMemberRoleTitleAdd
    CustomValidation =  validations.CheckMemberTitleDateAdd 


#def getMinistryDateFilter(Date):
#    return sql.or_(
#        sql.between(Date, domain.ministry.c.start_date, domain.ministry.c.end_date),
#        sql.and_( domain.ministry.c.start_date <= Date, domain.ministry.c.end_date == None)
#        )



qryAddQuestionMinistryVocab = sqlutils.SQLQuerySource(sqlstatements.sql_select_question_ministry_add, 'full_name', 'group_id')
        
class IQuestionAdd ( IQuestion ):
    """ Custom schema to override some autogenerated fields"""
    ministry_id = schema.Choice(title=_(u"Ministry"),  
                                source=qryAddQuestionMinistryVocab, 
                                required=False,
                                )        

class QuestionAdd( BungeniAddForm ):
    form_fields = form.Fields( IQuestionAdd ).select('question_type', 'response_type', 'owner_id', 'ministry_id',
                                                    'short_name', 'body_text',                                                                  
                                                    'note', 'receive_notification' )

    Adapts = IQuestionAdd
    CustomValidation =  validations.QuestionAdd 
    form_fields["note"].custom_widget = widgets.OneTimeEditor
    form_fields["body_text"].custom_widget = widgets.RichTextEditor 
    #getUserId( name )
    
    def update( self ):      
        ministry_id = getattr(self.context.__parent__, 'ministry_id', None)   
        if self.context.__parent__.__class__  == domain.Question:    
        #if ministry_id:
            #self.form_fields["ministry_id"].field.default = ministry_id
            #self.form_fields["ministry_id"].for_display = True
            self.form_fields = self.form_fields.omit("ministry_id")
        super( QuestionAdd, self ).update()  
        try:
            user_id = self.request.principal.user_id    
            #self.form_fields['owner_id'].field.default = [user_id]       
        except:
            pass            
         
        
    def can_submit( self, action):
        result = form.haveInputWidgets( self, action)
        result = result and prefs.getQuestionSubmissionAllowed()
        return result

#    def can_attach( self, action):
#        result = form.haveInputWidgets( self, action)
#        result = result and IFileAttachments.implementedBy( self.context )       
#        return result  

    @form.action(_(u"Save"), condition=form.haveInputWidgets)
    def handle_add_save(self, action, data ):
        """
        After succesfull creation of the content we are back at the listing
        """
        self.createAndAdd( data )
        name = self.context.domain_model.__name__
        self._next_url = absoluteURL( self.context, self.request ) + '?portal_status_message=%s Added'%name    
        
    @form.action(_(u"Cancel"), validator=null_validator )
    def handle_cancel( self, action, data ):
        """
        takes us back to the listing
        """
        url = self.nextURL()
        return self.request.response.redirect( url )
        
    @form.action(_(u"Save and continue editing"), condition=form.haveInputWidgets, validator='validateAdd')
    def handle_add_edit( self, action, data ):
        ob = self.createAndAdd( data )
        name = self.context.domain_model.__name__
        self._next_url = absoluteURL( ob, self.request ) + "/@@edit?portal_status_message=%s Added"%name
        
    @form.action(_(u"Save and add another"), condition=form.haveInputWidgets)
    def handle_add_and_another(self, action, data ):
        self.createAndAdd( data )
        name = self.context.domain_model.__name__
        self._next_url = absoluteURL( self.context, self.request ) + '/@@add?portal_status_message=%s Added'%name    
        
    @form.action(_(u"Save and submit to clerk"), condition=can_submit, validator='validateAdd')
    def handle_add_submit( self, action, data ):
        ob = self.createAndAdd( data )
        info = component.getAdapter( ob,  interfaces.IWorkflowInfo)
        if data.has_key('note'):
            notes = data['note']     
        else:
            notes=''                   
        createVersion(ob, notes)                                                                    
        info.fireTransition( 'submit-to-clerk', notes )                          
        name = self.context.domain_model.__name__
        self._next_url = absoluteURL( ob, self.request ) + "/?portal_status_message=%s Added"%name    
            
#    @form.action(_(u"Save and attach files"), condition=can_attach, validator='validateAdd')
#    def handle_add_attach( self, action, data ):
#        self.createAndAdd( data )
#        name = self.context.domain_model.__name__
#        self._next_url = absoluteURL( self.context, self.request ) + '/files?portal_status_message=%s Added'%name          

     
        
class ResponseAdd( BungeniAddForm ):
    """
    Answer a Question
    UI for ministry to input response
    Display the question when adding the answer.
    """
    form_fields = form.Fields( IResponse ).select('response_text', 'sitting_time') 
    Adapts = IResponse
    form_fields["response_text"].custom_widget=widgets.RichTextEditor 
    #form_fields["response_type"].custom_widget=widget.CustomRadioWidget
    CustomValidation =  validations.ResponseAdd

##############
# Edit forms      
##############

##############
#Generic Custom Edit form   


def hasDeletePermission(context):
    """
    generic check if the user has rights to delete the object the
    permission must follow the convention: bungeni.classname.delete
    where classname is the lowercase of the name of the python class
    """
    
    interaction = zope.security.management.getInteraction()
    class_name = context.__class__.__name__ 
    permission_name = 'bungeni.' + class_name.lower() +'.delete'
    return interaction.checkPermission(permission_name, context)



####
# Display invariant errors /  custom validation errors in the context of the field
# that raised the error.

def set_widget_errors(widgets, errors):
    for widget in widgets:
        name = widget.context.getName()
        for error in errors:
            if isinstance(error, interface.Invalid) and name in error.args[1:]:
                if widget._error is None:
                    widget._error = error




def flag_changed_widgets( widgets, context, data):
    for widget in widgets:
        name = widget.context.getName()
        # If the field is not in the data, then go on to the next one
        if name not in data:
            widget.changed = False
            continue
        if data[name] == getattr(context, name):
            widget.changed = False
        else:
            widget.changed = True  
    return []                  

class CustomEditForm ( EditFormViewlet ):
    """
    Override the autogenerated Edit form for specific behaviour
    """  
    Adapts = None
    CustomValidations = None
    template = NamedTemplate('alchemist.subform')       
    
    def _can_edit(self):
        """
        check for edit permissions
        """
        #TODO
        return True
    
    
    def _can_delete( self ):
        return hasDeletePermission(self.context)

    def _can_attach( self ):
        #result = form.haveInputWidgets( self, action)
        result =  IFileAttachments.providedBy( self.context )    
        return result      
    
    def _getDefaultActions(self):
        actions = []
        if self._can_edit():
            action = form.Action(_(u'Save'), success='handle_edit_action')
            action.form = self
            actions.append(action)
        if self._can_attach():
            action = form.Action(_(u'Attach a file'), success='handle_save_attach')
            action.form = self
            actions.append(action)
                            
        #cancel is allways available... 
        action = form.Action(_(u'Cancel'), success= 'handle_cancel_action')
        action.form = self   
        actions.append(action)

        if self._can_delete():                  
            action = form.Action(_(u'Delete'), success= 'handle_delete_action')
            action.form = self
            actions.append(action)   
        return actions          
     

    def setupActions( self ):
        self.actions = self._getDefaultActions()    
          
          
    def update( self ):
        """
        adapt the custom fields to our object
        """
        self.setupActions()  
        self.adapters = {self.Adapts  : self.context }    
        super( CustomEditForm, self).update()        
        set_widget_errors(self.widgets, self.errors)   
       
        
    def validate(self, action, data):    
        """
        validation that require context must be called here,
        invariants may be defined in the descriptor
        """                                          
        return (form.getWidgetsData(self.widgets, self.prefix, data) +
                 form.checkInvariants(self.form_fields, data) +
                 flag_changed_widgets( self.widgets, self.context, data) +     
                 self.CustomValidations( self.context, data) )  

    def invariantErrors( self ):        
        """ All invariant errors should be handled by the fields that raised them """
        return []    
        
    
    #form.action(_(u"delete"), condition=can_delete, validator=null_validator)
    def handle_delete_action( self, action, data):    
        """
        deletes the current content and takes you to the listing
        """        
        if self.can_delete(action):
            context = removeSecurityProxy(self.context)
            session = Session()
            session.delete(context)
            url = absoluteURL( self.context.__parent__, self.request )  + '?portal_status_message=Object deleted'
            return self.request.response.redirect( url )
    
    #form.action(_(u"Cancel"), condition=form.haveInputWidgets, validator=null_validator)
    def handle_cancel_action( self, action, data ):
        """ the cancel action will take us back to the display view"""
        #return handle_edit_action( self, action, data )                    
        url = absoluteURL( self.context, self.request )  + '?portal_status_message=No Changes'
        return self.request.response.redirect( url )
        
                
        
    #form.action(_(u"Save"), condition=form.haveInputWidgets)
    def handle_edit_action( self, action, data ):
        """ Save action will take us: 
        If there were no errors to the display view
        If there were Errors to the edit view
        """
        result = handle_edit_action( self, action, data )                                 
        if self.errors: 
            return result
        else:            
            url = absoluteURL( self.context, self.request )  
            return self.request.response.redirect( url )        

    #form.action(_(u"Save and attach files"), condition=can_attach )
    def handle_save_attach( self, action, data ):        
        result = handle_edit_action( self, action, data )                                 
        if self.errors: 
            return result
        else:            
            url = absoluteURL( self.context, self.request )   + '/files'
            return self.request.response.redirect( url  )    
                        
                      

membersEditVocab = sqlutils.SQLQuerySource(sqlstatements.sql_edit_members, 'user_name', 'user_id', {'member_id':'$member_id'} )      
  
# Parliament
class ParliamentEdit( CustomEditForm ):
    """
    Edit a parliament
    """
    form_fields = form.Fields( IParliament )
    form_fields["start_date"].custom_widget = SelectDateWidget
    form_fields["end_date"].custom_widget = SelectDateWidget  
    form_fields["election_date"].custom_widget = SelectDateWidget  
    form_fields["description"].custom_widget=widgets.RichTextEditor   
    Adapts = IParliament
    CustomValidations = validations.CheckParliamentDatesEdit
   
       

                              

class GovernmentEdit( CustomEditForm ): 
    """
    Edit a government
    """
    form_fields = form.Fields( IGovernment )
    form_fields["start_date"].custom_widget = SelectDateWidget
    form_fields["end_date"].custom_widget = SelectDateWidget
    form_fields["description"].custom_widget=widgets.RichTextEditor      
    Adapts = IGovernment
    CustomValidations = validations.CheckGovernmentsDateInsideParliamentsDatesEdit
    
# Sitting Attendance
             
  

class IGroupSittingAttendanceEdit( interface.Interface ):
    """ """
    member_id = schema.Choice(title=_(u"Member of Parliament"),  
                                source=membersEditVocab, 
                                required=True,
                                )
    attendance_id = schema.Choice( title=_(u"Attendance"),  
                                    source=attendanceVocab, 
                                    required=True,
                                    )  
   
class GroupSittingAttendanceEdit( EditFormViewlet ):
    """
    override the Edit Form for GroupSittingAttendance
    """
    form_fields = form.Fields( IGroupSittingAttendanceEdit )
    template = NamedTemplate('alchemist.subform')   
    def update( self ):
        """
        adapt the custom fields to our object
        """
        self.adapters = { IGroupSittingAttendanceEdit : self.context }        
        super( GroupSittingAttendanceEdit, self).update()
        set_widget_errors(self.widgets, self.errors)

# Sittings                    


class GroupSittingEdit( CustomEditForm ):
    """
    override the Edit Form for GroupSitting
    """
    form_fields = form.Fields( IGroupSitting )
    form_fields["start_date"].custom_widget = SelectDateTimeWidget
    form_fields["end_date"].custom_widget = SelectDateTimeWidget
    Adapts = IGroupSitting
    CustomValidations = validations.CheckSittingDatesInsideParentDatesEdit 

                 

class SessionsEdit ( CustomEditForm ):
    form_fields = form.Fields( IParliamentSession )
    form_fields["start_date"].custom_widget = SelectDateWidget
    form_fields["end_date"].custom_widget = SelectDateWidget 
    form_fields["notes"].custom_widget=widgets.RichTextEditor      
    Adapts = IParliamentSession
    CustomValidations = validations.CheckSessionDatesEdit    

membersEditVocab = sqlutils.SQLQuerySource(sqlstatements.sql_edit_members, 'user_name', 'user_id', {'member_id':'$user_id'} )  



substitutionsEditVocab = sqlutils.SQLQuerySource(sqlstatements.sql_editSubstitution, 'user_name', 'user_id', 
                                                    {'user_id':'$user_id', 'group_id' : '$group_id'} )  
    
class IMemberOfParliamentEdit( IMemberOfParliament ):
    """ Custom schema to override some autogenerated fields"""
    user_id = schema.Choice(title=_(u"Member of Parliament"),  
                                source=membersEditVocab, 
                                required=True,
                                )
    replaced_id = schema.Choice(title=_(u"substituted by"),  
                                source=substitutionsEditVocab, 
                                required=False,
                                )
    
class MemberOfParliamenEdit( CustomEditForm ):     
    Adapts = IMemberOfParliamentEdit          
    form_fields = form.Fields( IMemberOfParliamentEdit ).select(
                    'user_id', 'start_date', 
                    'election_nomination_date', 'elected_nominated',  'constituency_id',
                    'end_date', 'leave_reason',
                    'notes')
    form_fields["start_date"].custom_widget = SelectDateWidget
    form_fields["end_date"].custom_widget = SelectDateWidget
    form_fields["election_nomination_date"].custom_widget = SelectDateWidget
    form_fields["notes"].custom_widget=widgets.RichTextEditor          
    CustomValidations = validations.CheckMemberDatesEdit         

class CommitteeEdit ( CustomEditForm ):
    Adapts = ICommittee          
    form_fields = form.Fields( ICommittee )
    form_fields["start_date"].custom_widget = SelectDateWidget
    form_fields["end_date"].custom_widget = SelectDateWidget     
    form_fields["reinstatement_date"].custom_widget = SelectDateWidget  
    form_fields["description"].custom_widget=widgets.RichTextEditor            
    CustomValidations = validations.CheckCommitteeDatesEdit 

class ICommitteeMemberEdit( ICommitteeMember ):
    """ Custom schema to override some autogenerated fields"""
    user_id = schema.Choice(title=_(u"Comittee Member"),  
                                source=membersEditVocab, 
                                required=True,
                                )
    replaced_id = schema.Choice(title=_(u"substituted by"),  
                                source=substitutionsEditVocab, 
                                required=False,
                                )
    
        
class CommitteeMemberEdit( CustomEditForm ):
    Adapts = ICommitteeMemberEdit          
    form_fields = form.Fields( ICommitteeMemberEdit ).select(
                    'user_id', 
                    'start_date', 'end_date',
                    'notes')
    form_fields["start_date"].custom_widget = SelectDateWidget
    form_fields["end_date"].custom_widget = SelectDateWidget 
    form_fields["notes"].custom_widget=widgets.RichTextEditor         
    CustomValidations = validations.CommitteeMemberDatesEdit

class ICommitteeStaffEdit ( ICommitteeStaff ):
    """
    override some fields with custom schema
    """
    user_id = schema.Choice(title=_(u"Staff Member"),  
                                source=membersEditVocab, 
                                required=True,
                                )
    replaced_id = schema.Choice(title=_(u"substituted by"),  
                                source=substitutionsEditVocab, 
                                required=False,
                                )
                                
class CommitteeStaffEdit( CustomEditForm ):
    """
    override the AddForm 
    """
    form_fields = form.Fields( ICommitteeStaffEdit ).select(
                    'user_id', 
                    'start_date', 'end_date',
                    'notes')
    form_fields["start_date"].custom_widget = SelectDateWidget
    form_fields["end_date"].custom_widget = SelectDateWidget
    form_fields["notes"].custom_widget=widgets.RichTextEditor 
    Adapts = ICommitteeStaffEdit
    CustomValidation =  validations.CommitteeMemberDatesEdit   

   
class MinistryEdit( CustomEditForm ):
    Adapts = IMinistry   
    form_fields = form.Fields( IMinistry )
    form_fields["start_date"].custom_widget = SelectDateWidget
    form_fields["end_date"].custom_widget = SelectDateWidget 
    form_fields["description"].custom_widget=widgets.RichTextEditor         
    CustomValidations = validations.MinistryDatesEdit

class IMinisterEdit( IMinister ):
    """ Custom schema to override some autogenerated fields"""
    user_id = schema.Choice(title=_(u"Minister"),  
                                source=membersEditVocab, 
                                required=True,
                                )
    replaced_id = schema.Choice(title=_(u"substituted by"),  
                                source=substitutionsEditVocab, 
                                required=False,
                                )

class MinisterEdit( CustomEditForm ):
    Adapts = IMinisterEdit   
    form_fields = form.Fields( IMinisterEdit ).select(
                    'user_id', 
                    'start_date', 'end_date',
                    'notes')
    form_fields["start_date"].custom_widget = SelectDateWidget
    form_fields["end_date"].custom_widget = SelectDateWidget 
    form_fields["notes"].custom_widget=widgets.RichTextEditor         
    CustomValidations = validations.MinisterDatesEdit
    
class ExtensionGroupEdit( CustomEditForm ):
    Adapts = IExtensionGroup   
    form_fields = form.Fields( IExtensionGroup )
    form_fields["start_date"].custom_widget = SelectDateWidget
    form_fields["end_date"].custom_widget = SelectDateWidget 
    form_fields["description"].custom_widget=widgets.RichTextEditor         
    CustomValidations = validations.ExtensionGroupDatesEdit    
        
class IExtensionMemberEdit( IExtensionMember ):
    """ Custom schema to override some autogenerated fields"""
    user_id = schema.Choice(title=_(u"Member"),  
                                source=membersEditVocab, 
                                required=True,
                                )
    replaced_id = schema.Choice(title=_(u"substituted by"),  
                                source=substitutionsEditVocab, 
                                required=False,
                                )
       
class ExtensionMemberEdit( CustomEditForm ):
    Adapts = IExtensionMemberEdit   
    form_fields = form.Fields( IExtensionMemberEdit ).select(
                    'user_id', 
                    'start_date', 'end_date',
                    'notes')
    form_fields["start_date"].custom_widget = SelectDateWidget
    form_fields["end_date"].custom_widget = SelectDateWidget         
    form_fields["notes"].custom_widget=widgets.RichTextEditor 
    CustomValidations = validations.ExtensionMemberDatesEdit    
 

titleEditVocab =  sqlutils.SQLQuerySource(sqlstatements.sql_EditMemberTitle, 'ordered_title', 'user_role_type_id')
     
class IMemberRoleTitleEdit( IMemberRoleTitle ):
    title_name_id = schema.Choice( title=_(u"Title"),  
                                    source=titleEditVocab, 
                                    required=True,
                                    )  
     
class MemberTitleEdit( CustomEditForm ):
    form_fields = form.Fields( IMemberRoleTitleEdit ).select('title_name_id', 'start_date', 'end_date')
    form_fields["start_date"].custom_widget = SelectDateWidget
    form_fields["end_date"].custom_widget = SelectDateWidget
    Adapts = IMemberRoleTitleEdit
    CustomValidations =  validations.CheckMemberTitleDateEdit






qryEditQuestionMinistryVocab = sqlutils.SQLQuerySource(sqlstatements.sql_select_question_ministry_edit, 'full_name', 'group_id', 
                                                            {'parliament_id':'$parliament_id',})
        
class IQuestionEdit ( IQuestion ):
    """ Custom schema to override some autogenerated fields"""
    ministry_id = schema.Choice(title=_(u"Ministry"),  
                                source=qryEditQuestionMinistryVocab, 
                                required=False,
                                )        
        
class QuestionEdit( CustomEditForm ):
    """
    Edit a question.
    the workflow transitions are available as actions as well as the 
    default save and cancel buttons
    """
    form_fields = form.Fields( IQuestionEdit ).select('question_type', 'response_type', 'owner_id', 'ministry_id',
                                                    'short_name', 'body_text', 
                                                    'submission_date', 'approval_date',                                                    
                                                    'note', 'receive_notification' )
                    
                                                    
                                                    
    Adapts = IQuestionEdit
    form_fields["note"].custom_widget = widgets.OneTimeEditor
    form_fields["body_text"].custom_widget = widgets.RichTextEditor 
    form_fields['submission_date'].for_display = True
    form_fields['approval_date'].for_display = True    
    #form_fields['supplement_parent_id'].custom_widget = widgets.SupplementaryQuestionDisplay
#    form_fields['notes_display'].for_display = True  
#    form_fields['notes_display'].custom_widget = widgets.HTMLDisplay  
    CustomValidations =  validations.QuestionEdit
    

    
    

    
    def _can_delete(self):
        interaction = zope.security.management.getInteraction()
        return interaction.checkPermission('bungeni.question.delete', self.context)
        
    def _can_edit(self):
        interaction = zope.security.management.getInteraction()
        return interaction.checkPermission('bungeni.question.edit', self.context)    
    
    def _can_view(self):    
        interaction = zope.security.management.getInteraction()
        return interaction.checkPermission('bungeni.question.view', self.context)
    
    def _getDefaultActions(self):
        actions = []
        if self._can_edit():
            action = form.Action(_(u'Save'), success='handle_edit_action')
            action.form = self
            actions.append(action)
        #cancel is allways available... 
        action = form.Action(_(u'Cancel'), success= 'handle_cancel_action')
        action.form = self   
        actions.append(action)

        if self._can_delete():                  
            action = form.Action(_(u'Delete'), success= 'handle_delete_action')
            action.form = self
            actions.append(action)   
        return actions
    
    def handle_delete_action( self, action, data):
        """ 
        delete this object and return to container view
        """
        # we need a check here that the user has the rights to delete
        # the content, otherwise it it should fail!
        if self._can_delete():
            context = removeSecurityProxy(self.context)
            session = Session()
            session.delete(context)
            url = absoluteURL( self.context.__parent__, self.request )  + '?portal_status_message=Object deleted'
            return self.request.response.redirect( url )
        
    def handle_cancel_action( self, action, data ):
        """ the cancel action will take us back to the display view"""
        url = absoluteURL( self.context, self.request )  + '?portal_status_message=No Changes'
        return self.request.response.redirect( url )
            
    def handle_edit_action( self, action, data ):
        """ Save action will take us: 
        If there were no errors to the display view
        If there were Errors to the edit view
        """
        result = handle_edit_action( self, action, data )                                 
        if self.errors: 
            return result
        else:            
            url = absoluteURL( self.context, self.request ) 
            #create a version on every edit ...
            if data.has_key('note'):
                notes = data['note']     
            else:
                notes= ''                
            createVersion(self.context, notes)
            return self.request.response.redirect( url )        
    
    def setupActions( self ):
        self.wf = interfaces.IWorkflowInfo( self.context )
        transitions = self.wf.getManualTransitionIds()
        self.actions = self._getDefaultActions() + bindTransitions( self, transitions, None, interfaces.IWorkflow( self.context ) ) 
       

    def update( self ):
        self.setupActions()  
        super( QuestionEdit, self).update()
        self.setupActions()  # after we transition we have different actions      
        wf_state =interfaces.IWorkflowState( removeSecurityProxy(self.context) ).getState()
        self.wf_status = wf_state            
        

class ResponseEdit ( CustomEditForm ):
    """
    Answer a Question
    UI for ministry to input response
    Display the question when adding the answer.
    """
    form_fields = form.Fields( IResponse ).select('response_text', 'sitting_time') 
    Adapts = IResponse
    form_fields["response_text"].custom_widget=widgets.RichTextEditor 
    #form_fields["response_type"].custom_widget=widgets.CustomRadioWidget
    CustomValidations =  validations.ResponseEdit
    

class BungeniRSSEventView(BrowserView):   
    __call__ = ViewPageTemplateFile('templates/rss-event-view.pt') 
    form_name = None  





    # Required channel elements:
    
    def rssTitle( self ):
        """
        title	The name of the channel. 
        It's how people refer to your service. 
        If you have an HTML website that contains the same information as your RSS file, 
        the title of your channel should be the same as the title of your website.
        """ 
        return self.context.title
        
    def rssDescription ( self ):
        """
        description       	Phrase or sentence describing the channel.
        """
        return self.context.summary
        
    def rssLink( self ):
        """
        link	The URL to the HTML website corresponding to the channel.
        """
        return absoluteURL( self.context, self.request )                    
        
    # items of a channel:
    
    def rssItems( self ):
        """
        Elements of <item> 
        A channel may contain any number of <item>s. 
        An item may represent a "story" -- much like a story in a newspaper or magazine; 
        if so its description is a synopsis of the story, and the link points to the full story. 
        An item may also be complete in itself, if so, the description contains the text (entity-encoded HTML is allowed; 
        see examples), and the link and title may be omitted. 
        All elements of an item are optional, 
        however at least one of title or description must be present. 
        
        title	The title of the item.
        link	The URL of the item.
        description     	The item synopsis.
        pubDate	Indicates when the item was published. 
                
        """
        
        session = Session()
        bill_id = self.context.bill_id
        connection = session.connection(domain.Bill)
        results = connection.execute( sqlstatements.sql_bill_timeline % {'item_id' : bill_id} )       
        path = absoluteURL( self.context, self.request ) 
        rlist = []
        for result in results:
            rlist.append({'title': result.atype, 'description': result.title, 'date': result.adate.isoformat()})
        return rlist           
                



        
