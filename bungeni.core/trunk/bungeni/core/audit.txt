Audit:

in terms of a test plan, its a doc test, that creates a class, which
implements the auditable interface, 
see http://wiki.zope.org/zope3/events.html hoew to test events
Note: zope.app.event. was replaced with zope.lifecycleevent
see audit.zcml

  >>> import sqlalchemy as rdb
  >>> from datetime import datetime
  >>> metadata = rdb.MetaData()
  >>> from ore.alchemist import Session
  >>> from bungeni.models.schema import make_changes_table
  >>> from sqlalchemy.orm import mapper
  >>> import bungeni.core.audit as audit
  >>> import bungeni.core.interfaces
  >>> import zope.interface
  >>> import bungeni.models.domain as domain
  
Note that the Primary key must be user_id (tablename -'s' + '_id')
otherwise bungeni.core.schema.make_changes_table will fail

  >>> users_table = rdb.Table('users', metadata,
  ...     rdb.Column('user_id', rdb.Integer, primary_key=True),
  ...     rdb.Column('name', rdb.String(20)),
  ...     rdb.Column('fullname', rdb.String(20)),
  ...     rdb.Column('password', rdb.String(20))
  ... )

  >>> class Users(object):
  ...     zope.interface.implements(bungeni.models.interfaces.IBungeniContent)  
  

  >>> from zope.interface import classImplements
  >>> classImplements( Users, bungeni.core.interfaces.IAuditable)


  >>> mapper(Users, users_table)
  <sqlalchemy.orm.mapper.Mapper object at ...
  
  >>> user_changes = make_changes_table(users_table, metadata)
  
  >>> class UserChanges(object):
  ...     pass
  
  >>> mapper(UserChanges, user_changes)
  <sqlalchemy.orm.mapper.Mapper object at  ...

  >>> UsersAuditor = audit.AuditorFactory( user_changes )


test setup is creating a sqlite db:

  >>> metadata.bind = rdb.create_engine('sqlite://')
  >>> metadata.create_all()

  >>> session = Session()



create an instance of the class:
  >>> user = Users()
  >>> user.name="jdoe"
  >>> user.fullname ="John Doe"
  >>> user.password ="passwd"
  >>> session.save(user)
  >>> session.flush()
  
  >>> user.user_id
  1  
  
  
check that our changes table acts as expected

  >>> len(list(session.query(UserChanges)))
  0

  >>> change = UserChanges()
  >>> change.user_id = 1
  >>> session.save(change)
  >>> session.flush()
  

  >>> len(list(session.query(UserChanges)))
  1
  

setting up the event subscribers/adapters:

  >>> component.provideAdapter(
  ...    audit.AuditorFactory,
  ...    (bungeni.core.interfaces.IAuditable,),
  ...    bungeni.models.interfaces.IBungeniContent )

  >>> #domain.ItemLog.makeLogFactory( "UsersChange")


  >>> import zope.lifecycleevent
  >>> import zope.event

  
  >>> auditor = bungeni.core.interfaces.IAuditable(user, UsersAuditor)  

#  <subscriber
#     for=".interfaces.IAuditable
#          zope.lifecycleevent.IObjectModifiedEvent"
#     handler=".audit.objectModified"
#     trusted="True"
#     />

  >>> zope.component.provideHandler( audit.objectAdded,
  ...  [bungeni.core.interfaces.IAuditable , zope.lifecycleevent.IObjectCreatedEvent])

  >>> zope.component.provideHandler( audit.objectModified,
  ...  [bungeni.core.interfaces.IAuditable , zope.lifecycleevent.IObjectModifiedEvent])

  


broadcast an event:

  >>> event = zope.lifecycleevent.ObjectCreatedEvent(user)  
  >>> zope.component.event.objectEventNotify(event)
  
check the audit table: 

  >>> len(list(session.query(UserChanges)))
  2

broadcast an event:

  >>> event = zope.lifecycleevent.IObjectModifiedEvent(user)  
  >>> zope.component.event.objectEventNotify(event)


check the audit table: 

  >>> len(list(session.query(UserChanges)))
  3


Clean up:
  >>> session.flush()
  >>> session.commit()
  >>> session.close()
  
  

